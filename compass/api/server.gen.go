// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Enrich telemetry attributes with compliance control data
	// (POST /v1/enrich)
	PostV1Enrich(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// PostV1Enrich operation middleware
func (siw *ServerInterfaceWrapper) PostV1Enrich(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV1Enrich(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/v1/enrich", wrapper.PostV1Enrich)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"Vb5/dMPWgaqe/hcAAP//p/FzCeAXAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

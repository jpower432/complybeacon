// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Enrich telemetry attributes with compliance control data
	// (POST /v1/enrich)
	PostV1Enrich(c *gin.Context)
	// Batch retrieve static compliance metadata for multiple policy rules
	// (POST /v1/metadata/batch)
	PostV1MetadataBatch(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// PostV1Enrich operation middleware
func (siw *ServerInterfaceWrapper) PostV1Enrich(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV1Enrich(c)
}

// PostV1MetadataBatch operation middleware
func (siw *ServerInterfaceWrapper) PostV1MetadataBatch(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV1MetadataBatch(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/v1/enrich", wrapper.PostV1Enrich)
	router.POST(options.BaseURL+"/v1/metadata/batch", wrapper.PostV1MetadataBatch)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieve complete compliance metadata for policy evidence
	// (POST /v1/metadata)
	PostV1Metadata(c *gin.Context)
	// Batch retrieve compliance metadata for multiple policy rules
	// (POST /v1/metadata/batch)
	PostV1MetadataBatch(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// PostV1Metadata operation middleware
func (siw *ServerInterfaceWrapper) PostV1Metadata(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV1Metadata(c)
}

// PostV1MetadataBatch operation middleware
func (siw *ServerInterfaceWrapper) PostV1MetadataBatch(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostV1MetadataBatch(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/v1/metadata", wrapper.PostV1Metadata)
	router.POST(options.BaseURL+"/v1/metadata/batch", wrapper.PostV1MetadataBatch)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
